<!-- This is an example of single-player implementation of Backtrack using the iTunes Search API. -->
<!-- It is for reference only; not a part of the multiplayer build.-->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backtrack: Single Player</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Outfit:wght@700;800&display=swap"
        rel="stylesheet">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        void: '#0B0C10',
                        surface: '#1F2937',
                        indigo: { DEFAULT: '#6366F1', hover: '#4F46E5' },
                        success: '#10B981',
                        alert: '#EF4444',
                        timeline: '#F9FAFB',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        display: ['Outfit', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <style>
        /* Custom Styles for interactions */
        body {
            background-color: #0B0C10;
        }

        /* Card Flip Animation */
        .perspective-1000 {
            perspective: 1000px;
        }

        .transform-style-3d {
            transform-style: preserve-3d;
        }

        .backface-hidden {
            backface-visibility: hidden;
        }

        .rotate-y-180 {
            transform: rotateY(180deg);
        }

        /* Lock Button Progress */
        .btn-progress {
            width: 0%;
            transition: width 0.1s linear;
        }

        /* Vinyl Spin Animation */
        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        .spin-slow {
            animation: spin 4s linear infinite;
        }

        .paused {
            animation-play-state: paused;
        }

        /* Scrollbar hiding for cleaner UI */
        .hide-scroll::-webkit-scrollbar {
            display: none;
        }

        .hide-scroll {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>

<body class="text-gray-300 font-sans h-screen flex flex-col overflow-hidden selection:bg-indigo selection:text-white">

    <header class="h-20 border-b border-white/10 flex items-center justify-between px-8 bg-void z-10">
        <div class="flex items-center gap-3">
            <h1 class="font-display text-3xl text-white tracking-tight">Backtrack</h1>
            <span
                class="bg-indigo/20 text-indigo text-xs font-bold px-2 py-1 rounded uppercase tracking-wider">Solo</span>
        </div>
        <div class="flex items-center gap-4">
            <div class="text-right">
                <p class="text-xs text-gray-500 uppercase font-bold tracking-wider">Timeline</p>
                <p class="text-2xl font-display text-white"><span id="scoreDisplay">0</span> <span class="text-indigo">/
                        10</span></p>
            </div>
        </div>
    </header>

    <main class="flex-1 flex flex-col relative">

        <div class="flex-1 flex flex-col justify-center items-center bg-void relative">
            <div class="w-full h-full flex items-center overflow-x-auto hide-scroll px-12" id="timelineContainer">
                <div id="timelineList" class="flex gap-4 items-center min-w-full p-8 transition-all">
                </div>
            </div>

            <div class="absolute w-full h-px bg-white/10 -z-0 pointer-events-none"></div>
            <div class="absolute left-4 bottom-4 text-xs font-mono text-gray-600">OLDEST</div>
            <div class="absolute right-4 bottom-4 text-xs font-mono text-gray-600">NEWEST</div>
        </div>

        <div
            class="h-72 bg-surface border-t border-white/10 flex flex-col items-center justify-center relative p-6 shadow-2xl z-20">

            <div class="absolute top-0 left-0 w-full h-2 bg-gray-700">
                <div id="turnProgressBar" class="h-full bg-indigo transition-all duration-100 ease-linear"
                    style="width: 100%"></div>
            </div>

            <div id="gameControls" class="flex w-full max-w-5xl gap-8 items-center justify-center">

                <div class="w-64 text-center hidden" id="statusPanel">
                    <h3 class="text-white font-display text-xl mb-1" id="statusTitle">Listen...</h3>
                    <p class="text-sm text-gray-400" id="statusMessage">Drag the card to the timeline</p>
                    <div class="mt-4 font-mono text-2xl" id="timerText">00.0s</div>
                </div>

                <div id="stagingZone"
                    class="w-48 h-48 flex-shrink-0 border-2 border-dashed border-white/20 rounded-xl flex items-center justify-center bg-void/50">
                    <span class="text-xs text-gray-500 font-bold uppercase tracking-wider pointer-events-none">Current
                        Card</span>
                </div>

                <div class="w-64 flex flex-col items-center gap-4">
                    <div id="playerUI" class="flex items-center gap-4 opacity-50 transition-opacity">
                        <img id="vinylArt" src="https://placehold.co/100x100/1F2937/FFFFFF?text=Music"
                            class="w-16 h-16 rounded-full border-2 border-white/10 spin-slow paused shadow-lg">
                        <div class="text-left">
                            <div class="h-2 w-24 bg-gray-700 rounded mb-2 animate-pulse"></div>
                            <div class="h-2 w-16 bg-gray-700 rounded animate-pulse"></div>
                        </div>
                    </div>

                    <button id="lockBtn"
                        class="relative overflow-hidden group w-full bg-white text-void font-display font-bold text-lg py-4 rounded-xl shadow-lg transform transition active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed">
                        <span class="relative z-10 pointer-events-none">HOLD TO LOCK</span>
                        <div id="lockBtnFill" class="absolute top-0 left-0 h-full bg-indigo btn-progress z-0"></div>
                    </button>
                    <p class="text-xs text-gray-500">Hold for 1 second to confirm position</p>
                </div>
            </div>

            <div id="startScreen"
                class="absolute inset-0 bg-void/95 backdrop-blur-sm flex items-center justify-center z-50">
                <div class="text-center">
                    <h2 class="font-display text-5xl text-white mb-6">Ready?</h2>
                    <p class="text-gray-400 mb-8 max-w-md mx-auto">Turn up your volume. Arrange 10 songs in
                        chronological order to win.</p>
                    <button onclick="Game.init()"
                        class="bg-indigo hover:bg-indigo-hover text-white font-display font-bold text-xl px-12 py-4 rounded-full shadow-xl shadow-indigo/20 transition transform hover:scale-105">
                        Start Game
                    </button>
                </div>
            </div>

            <div id="winScreen"
                class="hidden absolute inset-0 bg-indigo/95 backdrop-blur-sm flex items-center justify-center z-50">
                <div class="text-center">
                    <h2 class="font-display text-5xl text-white mb-6">Timeline Complete!</h2>
                    <p class="text-white/80 mb-8 text-xl">You successfully placed 10 songs.</p>
                    <button onclick="location.reload()"
                        class="bg-white text-indigo font-display font-bold text-xl px-12 py-4 rounded-full shadow-xl transition transform hover:scale-105">
                        Play Again
                    </button>
                </div>
            </div>

        </div>
    </main>

    <script>
        const CONFIG = {
            totalTurnTime: 40,
            audioPlayTime: 30,
            requiredScore: 10
        };

        const DOM = {
            timelineList: document.getElementById('timelineList'),
            stagingZone: document.getElementById('stagingZone'),
            lockBtn: document.getElementById('lockBtn'),
            lockBtnFill: document.getElementById('lockBtnFill'),
            timerText: document.getElementById('timerText'),
            progressBar: document.getElementById('turnProgressBar'),
            vinyl: document.getElementById('vinylArt'),
            score: document.getElementById('scoreDisplay'),
            startScreen: document.getElementById('startScreen'),
            winScreen: document.getElementById('winScreen'),
            statusPanel: document.getElementById('statusPanel'),
            playerUI: document.getElementById('playerUI')
        };

        const Game = {
            deck: [],
            timeline: [], // Array of card objects currently on the board
            currentCard: null,
            audio: new Audio(),
            timer: null,
            timeLeft: 0,
            isLocked: false,
            isPlaying: false,
            lockPressTimer: null,

            async init() {
                try {
                    // Fetch cards
                    const response = await fetch('cards.json');
                    if (!response.ok) throw new Error("Could not load cards.json");
                    const data = await response.json();

                    // Shuffle Deck
                    this.deck = data.sort(() => Math.random() - 0.5);

                    DOM.startScreen.classList.add('hidden');
                    DOM.statusPanel.classList.remove('hidden');

                    // Init Sortables
                    this.initDragAndDrop();

                    // Place first card (Starter)
                    const starter = this.deck.pop();
                    this.addToTimeline(starter, true); // True = revealed
                    this.updateScore();

                    // Start first turn
                    this.startTurn();

                } catch (e) {
                    alert("Error: Ensure cards.json is in the same folder and you are running a local server.");
                    console.error(e);
                }
            },

            initDragAndDrop() {
                // Timeline List (Accepts items)
                new Sortable(DOM.timelineList, {
                    group: 'shared',
                    animation: 150,
                    ghostClass: 'opacity-50',
                    onEnd: (evt) => {
                        // Optional: Sound effect for drop
                    }
                });

                // Staging Zone (Source)
                new Sortable(DOM.stagingZone, {
                    group: 'shared',
                    sort: false,
                    animation: 150
                });
            },

            async startTurn() {
                if (this.timeline.length >= CONFIG.requiredScore) {
                    this.winGame();
                    return;
                }

                // Reset UI
                this.isLocked = false;
                DOM.lockBtn.disabled = true;
                DOM.lockBtnFill.style.width = '0%';
                DOM.stagingZone.innerHTML = '';
                DOM.progressBar.style.width = '100%';
                DOM.progressBar.classList.remove('bg-alert');
                DOM.progressBar.classList.add('bg-indigo');
                DOM.playerUI.classList.add('opacity-50');
                DOM.vinyl.classList.add('paused');

                // Get Card
                if (this.deck.length === 0) { alert("Deck empty!"); return; }
                this.currentCard = this.deck.pop();

                // Create Mystery Card Element
                const cardEl = this.createCardElement(this.currentCard, false);
                DOM.stagingZone.appendChild(cardEl);

                // Fetch Audio
                const songData = await this.fetchSongData(this.currentCard);

                if (songData && songData.previewUrl) {
                    this.audio.src = songData.previewUrl;
                    this.audio.volume = 1.0;
                    try {
                        await this.audio.play();
                        DOM.vinyl.classList.remove('paused');
                        DOM.vinyl.src = songData.artworkUrl100 || DOM.vinyl.src;
                        DOM.playerUI.classList.remove('opacity-50');
                    } catch (e) {
                        console.log("Autoplay blocked", e);
                    }
                } else {
                    console.warn("No audio found for", this.currentCard.title);
                    // We still play the turn, just without audio (Hard mode!)
                }

                // Enable Lock Button
                DOM.lockBtn.disabled = false;

                // Start Timer
                this.timeLeft = CONFIG.totalTurnTime;
                this.isPlaying = true;

                clearInterval(this.timer);
                this.timer = setInterval(() => this.gameLoop(), 100);
            },

            gameLoop() {
                this.timeLeft -= 0.1;

                // Update UI
                DOM.timerText.innerText = Math.max(0, this.timeLeft).toFixed(1) + 's';
                const pct = (this.timeLeft / CONFIG.totalTurnTime) * 100;
                DOM.progressBar.style.width = pct + '%';

                // Audio Logic (Fade out music at 30s mark of gameplay, i.e., 10s left on clock)
                // The prompt asked for: 30s music, then 10s silence. 
                // So if TimeLeft < 10, silence.
                if (this.timeLeft <= (CONFIG.totalTurnTime - CONFIG.audioPlayTime)) {
                    if (this.audio.volume > 0.1) {
                        this.audio.volume -= 0.1; // Quick fade
                    } else {
                        this.audio.pause();
                        DOM.vinyl.classList.add('paused');
                    }
                }

                // Panic Mode (Last 5s)
                if (this.timeLeft <= 5) {
                    DOM.progressBar.classList.remove('bg-indigo');
                    DOM.progressBar.classList.add('bg-alert');
                    DOM.timerText.classList.add('text-alert');
                } else {
                    DOM.timerText.classList.remove('text-alert');
                }

                // Time Up
                if (this.timeLeft <= 0) {
                    this.resolveTurn(true); // Force resolve
                }
            },

            async fetchSongData(card) {
                const query = `${card.title} ${card.artist}`;
                const encoded = encodeURIComponent(query);
                try {
                    const res = await fetch(`https://itunes.apple.com/search?term=${encoded}&entity=song&limit=1`);
                    const json = await res.json();
                    return json.results[0];
                } catch (e) {
                    return null;
                }
            },

            createCardElement(cardData, isRevealed) {
                const div = document.createElement('div');
                div.className = "relative w-40 h-40 cursor-grab active:cursor-grabbing perspective-1000";
                div.setAttribute('data-year', cardData.year);
                div.id = `card-${cardData.year}-${Math.floor(Math.random() * 1000)}`;

                const inner = document.createElement('div');
                inner.className = `w-full h-full relative transform-style-3d transition-transform duration-700 shadow-xl rounded-xl ${isRevealed ? '' : 'rotate-y-180'}`; // If not revealed, we actually show the "Back" which is the mystery face? 
                // Wait, logic:
                // Front Face: The Revealed Info (Year/Artist)
                // Back Face: The Mystery Logo
                // If isRevealed is FALSE, we want to show Back Face. So we rotate 180.

                // 1. Front Face (Revealed)
                const front = document.createElement('div');
                front.className = "absolute inset-0 backface-hidden bg-white rounded-xl flex flex-col items-center justify-center p-3 text-center border-4 border-white";
                front.innerHTML = `
                    <h2 class="font-display text-4xl text-void font-bold">${cardData.year}</h2>
                    <p class="text-xs font-bold text-indigo uppercase mt-2 line-clamp-1">${cardData.title}</p>
                    <p class="text-[10px] text-gray-500 line-clamp-1">${cardData.artist}</p>
                `;

                // 2. Back Face (Mystery) - "Front" visually when face down
                const back = document.createElement('div');
                back.className = "absolute inset-0 backface-hidden rotate-y-180 bg-gradient-to-br from-indigo-600 to-indigo-900 rounded-xl flex items-center justify-center border-2 border-white/20";
                back.innerHTML = `<span class="font-display text-4xl text-white opacity-50">?</span>`;

                inner.appendChild(front);
                inner.appendChild(back);
                div.appendChild(inner);

                return div;
            },

            addToTimeline(card, revealed) {
                const el = this.createCardElement(card, revealed);
                DOM.timelineList.appendChild(el);

                // If we are just setting up board, we push to logic array
                this.timeline.push(card);
                this.timeline.sort((a, b) => a.year - b.year); // Keep logic state sorted
            },

            resolveTurn(forceFail = false) {
                clearInterval(this.timer);
                this.isPlaying = false;
                this.audio.pause();
                DOM.lockBtn.disabled = true;

                // 1. Find the card element in the DOM
                // Because dragging moves the actual element, we just look for the ID
                // However, we need to know WHERE it is in the list.
                const cardEls = Array.from(DOM.timelineList.children);
                const playedCardEl = cardEls.find(el => el.getAttribute('data-year') == this.currentCard.year && el.querySelector('.opacity-50')); // find the mystery one

                if (!playedCardEl || forceFail) {
                    // Card not on timeline (still in staging) or time ran out
                    this.handleFail(playedCardEl);
                    return;
                }

                const placedIndex = cardEls.indexOf(playedCardEl);

                // 2. Validate Position
                // We need to check the years of the neighbors.
                const leftEl = cardEls[placedIndex - 1];
                const rightEl = cardEls[placedIndex + 1];

                const year = this.currentCard.year;
                const leftYear = leftEl ? parseInt(leftEl.getAttribute('data-year')) : -Infinity;
                const rightYear = rightEl ? parseInt(rightEl.getAttribute('data-year')) : Infinity;

                if (year >= leftYear && year <= rightYear) {
                    this.handleSuccess(playedCardEl);
                } else {
                    this.handleFail(playedCardEl);
                }
            },

            handleSuccess(el) {
                // Flash Green
                el.children[0].classList.remove('rotate-y-180'); // Flip to reveal
                el.children[0].querySelector('.bg-white').classList.add('ring-4', 'ring-success');

                // Update Logic State
                this.timeline.push(this.currentCard);
                this.timeline.sort((a, b) => a.year - b.year);

                this.updateScore();

                setTimeout(() => {
                    el.children[0].querySelector('.bg-white').classList.remove('ring-4', 'ring-success');
                    this.startTurn();
                }, 2000);
            },

            handleFail(el) {
                // Visual Fail
                if (el) {
                    el.classList.add('animate-bounce'); // Shake/Bounce
                    el.children[0].classList.add('ring-4', 'ring-alert');
                    setTimeout(() => {
                        el.remove(); // Discard
                        this.startTurn();
                    }, 1500);
                } else {
                    // Was never placed
                    this.startTurn();
                }
            },

            updateScore() {
                DOM.score.innerText = this.timeline.length;
            },

            winGame() {
                DOM.winScreen.classList.remove('hidden');
                // Could trigger confetti here
            }
        };

        // --- Event Listeners for "Hold to Lock" ---

        let pressStartTime;
        let pressInterval;

        function startPress(e) {
            if (e.type === 'mousedown' && e.button !== 0) return; // Only left click
            if (!Game.isPlaying || Game.isLocked) return;

            pressStartTime = Date.now();
            DOM.lockBtn.classList.add('scale-95');

            pressInterval = setInterval(() => {
                const elapsed = Date.now() - pressStartTime;
                const pct = Math.min((elapsed / 1000) * 100, 100);
                DOM.lockBtnFill.style.width = pct + '%';

                if (elapsed >= 1000) {
                    Game.isLocked = true;
                    clearInterval(pressInterval);
                    DOM.lockBtn.classList.remove('scale-95');
                    Game.resolveTurn();
                }
            }, 16);
        }

        function cancelPress() {
            if (Game.isLocked) return;
            clearInterval(pressInterval);
            DOM.lockBtnFill.style.width = '0%';
            DOM.lockBtn.classList.remove('scale-95');
        }

        DOM.lockBtn.addEventListener('mousedown', startPress);
        DOM.lockBtn.addEventListener('mouseup', cancelPress);
        DOM.lockBtn.addEventListener('mouseleave', cancelPress);

        // Touch support
        DOM.lockBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startPress(e); });
        DOM.lockBtn.addEventListener('touchend', cancelPress);

    </script>
</body>

</html>